## 第一个例子：k-最近邻算法
k-最邻近算法是一种用于分类的基本机器学习算法。  
它基于训练数据集中 k 个与测试范例标签最相似的范例确定测试范例的标签。

该算法的主要组成部分如下所示：
-	**训练数据集**  
该数据集由实例构成，其中包括定义每个实例的一个或者多个属性，以及一个可确定实例标签的特殊属性。

-	**距离指标**  
该指标用于确定训练数据集的实例与你想要分类的新实例之间的距离（或者说相似度）。
-	**测试数据集**  
该数据集用于度量算法的行为。

对某个实例进行分类时，该算法计算该实例和训练数据集所有实例的距离。  
然后，选取 k 个距离最邻近的实例并且查看这些实例的标签。  
实例最多的标签将被指派为输入实例的标签。

### 数据集和指标选择
-	采用 **UCI机器学习资源库**（UCI Machine Learning Repository）的 **Bank Marketing** 数据集。    

-	为了度量实例之间的距离，我们将采用**欧氏距离**（Euclidean distance）。  

该指标要求实例的所有属性必须有数值。  
Bank Marketing 数据集的一些属性是“类别型的”，也就是说，这些属性可以从一些预定义值中取值，这样就不能直接对该数据集使用欧氏距离。  

可以为每个类别型的值指派一个序号。
例如，对于婚姻状况来说，可用 0 代表单身，1 代表已婚，2 代表离婚。  
然而，这可能意味着离婚的人与已婚的人之间的距离要比其与单身的人之间的距离更近，而这一点也值得商榷。  

如果使所有的类别型取值的距离相同，还要为此单独创建属性。  
例如已婚、单身和离婚，而每个属性都只有两个值：0（否）和 1（是）。

## k-最近邻算法：串行版本
[代码实现](J2SerialVersionKNearestNeighbors.java)

## k-最近邻算法：并发版本
k-最近邻算法的串行版本，在如下两处可以进行算法的并行处理：
-	**距离的计算**：  
在每次循环迭代中都会计算输入范例和训练集某个范例之间的距离，而每次迭代均独立于其他各次迭代。

-	**距离的排序**：  
Java 8 在 Array 类中引入了 parallelSort() 方法，可以使用并行方式对数组进行排序。


### k-最近邻算法：细粒度并发版本
为待计算范例间的每个距离创建一个任务，也使距离数组的并发排序成为可能。

Java 并发 API 提供的一种同步机制： `CountDownLatch` 类。  
该类允许一个线程一直等待，直到其他线程到达其代码的某一确定点。  

该类需要使用等待线程数进行初始化，它实现了以下两种方法。
-	`getDown()` ：该方法用于减少要等待的线程数。

-	`await()` ：该方法挂起调用它的线程，直到计数器达到 0 为止。

[代码实现](J2ConcurrentVersionKNearestNeighborsByFineGrained.java)

### k-最近邻算法：粗粒度并发版本

[代码实现](J2ConcurrentVersionKNearestNeighborsByCoarseGrained.java)


## 测试结果

```
Train: 39129
Test: 2059
k-最近邻算法：串行版本 - 
K: 10    Success: 1873  Mistakes: 186,useTime: 34532

k-最近邻算法：粗粒度并发版本-不排序 -
K: 10    Success: 1873  Mistakes: 186,useTime: 33709

k-最近邻算法：粗粒度并发版本-排序 - 
K: 10    Success: 1873  Mistakes: 186,useTime: 22084

k-最近邻算法：细粒度并发版本-不排序 - 
K: 10    Success: 1873  Mistakes: 186,useTime: 52587

k-最近邻算法：细粒度并发版本-排序 - 
K: 10    Success: 1873  Mistakes: 186,useTime: 40844
```